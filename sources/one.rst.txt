Учебник питона
==============

Разжигая ваш аппетит
--------------------

Если вы много работаете на компьютерах, в конце концов обнаружите, что есть некоторые задачи, которые вы хотели бы автоматизировать. Так возможно вам хочется выполнить операцию поиска и замены над большим количеством текстовых файлов, или переименовать и переупорядочить группу файлов фотографий со сложным путем к ним. Возможно вы хотели бы написать маленькую пользовательскую базу данных или специализированное GUI-приложение или простую игру.

Если вы профессиональный разработчик программного обеспечения, вам возможно приходится работать с несколькими C/C++/Java библиотеками, но вы находите обычный цикл записи/компиляции/тестирования/перекомпиляции слишком медленным. Возможно вы пишете набор тестов для такой библиотеки и находите написание тестирующего кода утомительной задачей. Или, может быть, вы написали программу, которая может использовать язык расширения, и не хотите разрабатывать и реализовывать целый новый язык для вашего приложения.

Python - просто язык для вас.

Вы могли бы написать скрипт для командной оболочки Unix или пакеты файлов Windows для некоторых подобных задач, но shell-скрипты самое лучшее для перемещения окружающих файлов и изменении текстовых данных, не очень хорошо подходит для GUI-приложений или игр. Вы могли бы написать C/C++/Java программу, но это может занять много времени разработки, чтобы получить даже первый черновой вариант программы. Python проще в использовании, доступен на операционных системах Windows, Mac OS X и Unix и поможет сделать эту работу более быстро.

Python прост в использовании, но это реальный язык программирования, предлагающий намного больше структуры и поддержки для больших программ, чем могут предложить shell-скрипты или пакеты файлов. С другой стороны, Python также предлагает намного больше проверки ошибок, чем C, и, будучи весьма высоко-уровневым языком, он имеет встроенные высоко-уровневые типы данных, такие как гибкие массивы данных и словари. Из-за его более общих типов данных Python применим к гораздо более обширной сфере проблем, чем Awk или даже Perl, однако многое по меньшей мере также легко сделать в Python, как и в тех языках.

Python позволяет разделить вашу программу на модули, которые могут быть повторно использованы в других программах на Python. Он поставляется с большой коллекцией стандартных модулей, которые вы можете использовать в качестве основы ваших программ, или в качестве примеров, чтобы начать обучение программировать на Python. Некоторые из этих модулей предоставляют такие вещи как файловый ввод/вывод, системные вызовы, сокеты и даже интерфейсы инструментария GUI, такого как Tk.

Python - интерпретируемый язык, который может сберечь вам много времени в процессе разработки программы, т. к. нет необходимости в компиляции и компоновке. Интерпретатор может использоваться в интерактивном режиме, который позволяет легко экспериментировать с особенностями языка, писать одноразовые программы или тестировать функции при разработке программ "снизу вверх". Это также удобный настольный калькулятор.

Python позволяет программам быть написанными компактно и читаемо. Программы, написанные на Python, обычно намного короче, чем эквивалентные программы на C, C++ или Java, по нескольким причинам:

* высоко-уровневые типы данных позволяют вам выражать комплекс операций в одном высказывании;
* группировка высказываний осуществляется отступом, а не скобками начала и конца;
* нет необходимости в объявлении переменных или аргументов.
* Python расширяем: если вы знаете, как программировать на C, то легко добавите в интерпретатор встроенную функцию или модуль как для выполнения критических операций на максимальной скорости, так и свяжите Python-программу с библиотеками, которые могут быть доступны только в бинарной форме (такие как графические библиотеки конкретного производителя). Когда действительно войдете во вкус, можете связывать интерпретатор Python с приложениями, написанными на C, и использовать его, как язык расширения или команд для того приложения.

Кстати, язык назван в честь шоу BBC “Monty Python’s Flying Circus” ("Летающий цирк Монти Пайтона") и не имеет ничего общего с рептилиями. Создание ссылок на пародии Монти Пайтона в документации не только позволительно, это приветствуется!

Теперь когда вы все взволнованы Python, вы захотите изучить его более детально. Поскольку лучшим способом выучить язык является его использование, учебник приглашает вас поиграть с интерпретатором Python во время чтения.

В следующей главе объясняется принцип использования интерпретатора. Это довольно обыденная информация, но следует опробовать примеры, приведенные ниже.

Остальная часть учебника знакомит с различными особенностями языка Python и системы на примерах, начиная с простых выражений, высказываний и типов данных, через функции и модули, и, наконец, касаясь продвинутых концепций, таких как исключения и пользовательские классы.

Передача аргумента
------------------

Как известно для интерпретатора имя скрипта и дополнительные аргументы впоследствии превращаются в список строк и присваиваются переменной argv модуля sys. Вы можете обращаться к этому списку, выполняя import sys. Длина списка по крайней мере равна одному; когда не передано ни одного скрипта и аргумента, то sys.argv[0] является пустой строкой. Когда имя скрипта передается как '-' (означает стандартный ввод), sys.argv[0] устанавливается в '-'. При использовании -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command, sys.argv[0] устанавливается в '-c'. При использовании -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module, sys.argv[0] устанавливается к полному имени местонахождения модуля. Опции, обнаруженные после -c (docs.python.org/3/using/cmdline.html#cmdoption-c) command или -m (docs.python.org/3/using/cmdline.html#cmdoption-m) module не потребляются обработчиком опций интерпретатора Python, а оставляются в sys.argv для обработки командой или модулем.

Интерактивный режим
-------------------

Когда команды считываются из tty (терминала - прим. пер.), интерпретатору говорится быть в interactive mode (интерактивном режиме - прим. пер.). В этом режиме он предлагает ввести следующую команды с primary promp (первичного приглашения - прим. пер.), обычно три знака "больше, чем" (>>>); для продолжения строк он подсказывает с secondary prompt (вторичного приглашения - прим. пер.), по умолчанию три точки (...). Интерпретатор выводит приветственное сообщение, начинающееся с его номера версии и уведомления об авторских правах, перед выводом первого приглашения:

Кодировка исходного кода
------------------------

По умолчанию исходные файлы Python рассматриваются как кодированные в UTF-8. В этой кодировке символы большинства языков мира могут быть использованы одновременно в строковых литералах, идентификаторах и комментариях - хотя стандартная библиотека использует только символы ASCII для идентификаторов, это соглашение, которому должен следовать любой переносимый код. Чтобы отобразить все эти символы должным образом, ваш редактор должен распознавать, что файл в кодировке UTF-8, и он должен использовать шрифт, который поддерживает все символы в файле.

Чтобы объявить кодировку отличную от той, что используется по-умолчанию, первой строкой файла должна быть добавлена специальная строка комментария.

Несколько слов об именах и объектах
-----------------------------------

У объектов есть индивидуальность, и несколько имен (в несколько областях видимости) могут быть связаны с одним и тем же объектом. Это известно как использование псевдонимов (aliasing) в других языках. Обычно это не принимается во внимание при первом знакомстве с Python, и это можно спокойно игнорировать при работе с неизменными основными типами (числами, строками, кортежами). С другой стороны, использование псевдонимов предоставляет возможность неожиданного эффекта от семантики кода Python с участием изменяемых объектов, таких как списки, словари и множества других типов. Это обычно несет пользу для программы, так как псевдонимы в некоторых отношениях ведут себя как указатели. Например, передать объект легче, так как реализацией передается только указатель; и если функция изменяет объект, переданный в качестве аргумента, в вызывающей части кода будут наблюдаться изменения - это устраняет необходимость для двух различных механизмов передачи параметров как в Pascal.

Области видимости и пространства имен в Python
----------------------------------------------

Перед введением в классы, сначала необходимо кое-что сказать о правилах областей видимости в Python. Определения классов выполняют небольшие аккуратные трюки с пространствами имен, и вы должны знать, как работают области видимости и пространства имен, чтобы хорошо понимать, что происходит. Кстати, знания в этой области полезны для любого продвинутого программиста на Python.

Давайте начнем с некоторых определений.

namespace (пространство имен) представляет собой отображение имен на объекты. Большинство пространств имен в настоящее время реализованы как словари Python, но в любом случае это обычно не заметно (за исключением производительности), и это может измениться в будущем. Примеры пространств имен: множество встроенных имен (содержащие такие функции, как abs() (docs.python.org/3/library/functions.html#abs) и встроенные имена исключений); глобальные имена в модуле и локальные имена в вызове функции. В определенном смысле набор атрибутов объекта также образует пространство имен. Важная деталь в знаниях о пространствах имен заключается в том, что нет абсолютно никакой связи между именами в разных пространствах; например, в двух различных модулях может быть определена функция maximize, и это не создаст путаницы - пользователи модулей должны использовать префикс в виде имени модуля перед именем функции.

Кстати, слово attribute я использую для любого имени после точки - например, в выражении z.real, real является атрибутом объекта z. Строго говоря, ссылки на имена в модулях - это ссылки атрибутов: в выражении modname.funcname, modname - это объект модуля, а funcname является его атрибутом. В этом случае существует простое отображение между атрибутами модуля и глобальными именами, определенными в модуле: они разделяют одно и то же пространство имен! [1]

Атрибуты могут быть только для чтения или изменяемыми. В последнем случае, возможно присвоение атрибутов. Атрибуты модуля доступны для записи: вы можете написать modname.the_answer = 42. Записываемые атрибуты могут также быть удалены с помощью оператора del (docs.python.org/3/reference/simple_stmts.html#del). Например, del modname.the_answer удалит атрибут the_answer у объекта modname.

Пространства имен создаются в различные моменты времени и имеют разные периоды жизни. Пространство, содержащее встроенные имена, создается, когда запускается интерпретатор Python, и никогда не удаляется. Глобальное пространство имен для модуля создается, когда определение модуля считывается; обычно пространство имен модуля также существует до выхода из интерпретатора. Операторы, выполняющиеся на высшем уровне вызова интерпретатора, либо читающиеся из файла скрипта или интерактивно, рассматриваются как часть модуля под названием __main__ (docs.python.org/3/library/__main__.html#module-__main__), поэтому они имеют свое собственные глобального пространство имен. (Встроенные имен на самом деле находятся в модуле, который называется builtins (docs.python.org/3/library/builtins.html#module-builtins).)

Локальное пространство имен функции создается при ее вызове и удаляется, когда функция возвращает управление или вызывает исключение, которое не обрабатывается внутри нее. (Действительно, забывчивость была бы лучшим способом описать то, что происходит на самом деле.) Конечно, рекурсивные вызовы имеют свои собственные локальные имена.

scope (область видимости) является буквальной областью Python-программы, где непосредственно доступно пространство имен. "Непосредственно доступно" здесь означает, что "неспецифическая" ссылка на имя пытается найти имя в пространстве имен.

Хотя области (scopes) определяются статически, но используются динамически. В любое время выполнения есть по крайней мере три вложенные области видимости, чьи пространства имен доступны сразу:

* внутренняя область видимости, которая просматривается в первую очередь, содержит локальные имена
* область любых ограждающих функций, которая просматривается, начиная с ближайшей области видимости, содержит нелокальные, но и неглобальные имена
* предпоследняя область видимости включает глобальные имена текущего модуля
* внешняя область (исследуется последней) является пространством имен, содержащем встроенные имена
* Если имя объявлено как глобальное, то все ссылки и присвоения переходят непосредственно к средней области видимости, содержащей глобальные имена модуля. Для переназначения переменных, находящихся вне внутренней области видимости, может быть использован оператор nonlocal (docs.python.org/3/reference/simple_stmts.html#nonlocal); если такого объявления нет, эти переменные доступны только для чтения (попытка записи в такую переменную будет просто создавать новую локальную переменную в самой внутренней области видимости, в результате чего внешняя переменная с таким же именем остается без изменений).

Обычно локальная область ссылается на локальные имена (текстуально) текущей функции. Вне функций ссылки локальной области - то же самое, что пространство имен глобальной области: пространство имен модуля. Определения классов размещают еще одно пространство имен в локальной области.

Важно понимать, что области видимости определяются текстуально: глобальная область функции, определенной в модуле, есть пространство имен этого модуля, независимо от того, где и под каким псевдонимом вызывается функция. С другой стороны, фактический поиск имен производится динамически, во время выполнения. Тем не менее, определение языка развивается в сторону статического разрешения имен, ко времени "компиляции", так что не полагайтесь на динамическое разрешение имен! (На самом деле, локальные переменные уже определены статически.)

Специальная причуда Python - если нет оператора global, присвоения имен всегда идут в самые внутренние области. Присваивания не копируют данные - они просто связывают имена с объектами. То же самое верно для удалений: оператор del x убирает привязку х из пространства имен, на которые ссылается локальная область видимости. На самом деле все операции, которые вводят новые имена используют локальную область: в частности, оператор import (docs.python.org/3/reference/simple_stmts.html#import) и определения функций связывают модуль или имя функции в локальной области видимости.

Оператор global может быть использован для указания, какие определенные переменные находятся в глобальной области и должны быть отосланы туда; оператор nonlocal указывает, что некоторые переменные находятся в огражденной области видимости и должны быть отосланы туда.

`Вернуться к началу <index.html>`_